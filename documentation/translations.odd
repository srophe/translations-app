<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.tei-c.org/release/xml/tei/custom/schema/relaxng/tei_odds.rng" type="application/xml"
	schematypens="http://purl.oclc.org/dsdl/schematron"?>
<TEI 
   xmlns="http://www.tei-c.org/ns/1.0" 
   xmlns:sch="http://purl.oclc.org/dsdl/schematron"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
   
   <teiHeader>
      <fileDesc>
         <titleStmt>
            <title>TEI P5 ODD Customization for Syriaca.org's Mayana Corpus of Syriac Texts in English Translation</title>
         </titleStmt>
         <publicationStmt>
            <publisher>Mayana: A Corpus of Syriac Texts in English Translation</publisher>
            <availability status="free">
               <licence target="https://creativecommons.org/licenses/by/4.0/">Creative Commons
                  Attribution 4.0 International</licence>
            </availability>
         </publicationStmt>
         <sourceDesc>
            <p>This born digital ODD provides a customization of the TEI P5 All.</p>
         </sourceDesc>
      </fileDesc>
   </teiHeader>
   <text>
      <body>
         <opener></opener>
         <divGen type="toc" xml:id="toc"/>
         <div xml:id="documentation">
            
         </div>
         <div xml:id="schema">
            <head><title></title></head>
            <schemaSpec ident="Translations" start="TEI">
               <moduleRef key="core"></moduleRef>
               <moduleRef key="header"></moduleRef>
               <moduleRef key="linking"></moduleRef>
               <moduleRef key="namesdates"></moduleRef>
               <moduleRef key="tei"></moduleRef>
               <moduleRef key="textstructure"></moduleRef>
               <moduleRef key="transcr"/>
               
               
               <!--<classSpec type="atts" ident="att.global" mode="change">
                  <attList>
                     <attDef ident="dir">
                        <valList type="closed">
                           <valItem ident="rtl">
                              <desc>Indicates to Oxygen XML Editor that text is to be rendered right-to-left.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </classSpec>-->
               
               
               <elementSpec ident="ab" module="linking" mode="change">
                  <content>
                     <sequence preserveOrder="false">
                        <textNode/>
                        <elementRef key="choice" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="ellipsis" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="foreign" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="hi" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="pb" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="persName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="ptr" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="quote" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="title" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
                  <constraintSpec ident="ab" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:ab">
                           <sch:report test="ancestor::teiHeader">
                              The element &lt;ab&gt; is not allowed in the &lt;teiHeader&gt;.
                           </sch:report>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="n-on-ab" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:text//tei:ab">
                           <sch:let name="expectedNumber" value="count(preceding::tei:ab) + 1"/>
                           <sch:assert test="number(@n) = $expectedNumber">
                              The element &lt;ab&gt; is out of sequence. The @n attribute is numbered <sch:value-of select="@n"/> 
                              but it should be <sch:value-of select="$expectedNumber"/>.
                           </sch:assert>
                        </sch:rule>
                        </constraint>
                  </constraintSpec>
                  <constraintSpec ident="ID-on-ab-solo-div" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:body//tei:div[not(contains(@xml:id, '-'))]/child::tei:ab[preceding-sibling::tei:ab]">
                           <sch:let name="parentID" value="parent::tei:div/@xml:id"/>
                           <sch:let name="previousIDAtt" value="preceding-sibling::tei:ab[1]/@xml:id"/>
                           <sch:let name="previousSequence" value="number(replace($previousIDAtt, '\D+', ''))"/>
                           <sch:let name="expectedSequence" value="$previousSequence + 1"/>
                           <sch:let name="expectedIDAtt" value="concat($parentID, '-', $expectedSequence)"/>
                           <sch:assert test="@xml:id = $expectedIDAtt">
                              The @xml:id attribute is "<sch:value-of select="@xml:id"/>" 
                              but in order to match the text structure it should be 
                              "<sch:value-of select="$expectedIDAtt"/>".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:body//tei:div[not(contains(@xml:id, '-'))]/child::tei:ab[1]/@xml:id">
                           <sch:let name="parentDivID" value="parent::tei:ab/parent::tei:div/@xml:id"/>
                           <sch:assert test=". = concat($parentDivID, '-1')">
                              This @xml:id attribute is "<sch:value-of select="."/>" 
                              but it should be "<sch:value-of select="concat($parentDivID, '-1')"/>".
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="ID-on-ab-multiple-div" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:body//tei:div[contains(@xml:id, '-')]/child::tei:ab[preceding-sibling::tei:ab]">
                           <sch:let name="parentID" value="parent::tei:div/@xml:id"/>
                           <sch:let name="previousIDAtt" value="preceding-sibling::tei:ab[1]/@xml:id"/>
                           <sch:let name="previousSequence" value="number(tokenize($previousIDAtt, '\.')[last()])"/>
                           <sch:let name="expectedSequence" value="$previousSequence + 1"/>
                           <sch:let name="expectedIDAtt" value="concat($parentID, '.', $expectedSequence)"/>
                           <sch:assert test="@xml:id = $expectedIDAtt">
                              The @xml:id attribute is "<sch:value-of select="@xml:id"/>" 
                              but in order to match the text structure it should be 
                              "<sch:value-of select="$expectedIDAtt"/>".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:body//tei:div[contains(@xml:id, '-')]/child::tei:ab[1]/@xml:id">
                           <sch:let name="parentDivID" value="parent::tei:ab/parent::tei:div/@xml:id"/>
                           <sch:assert test=". = concat($parentDivID, '.1')">
                              This @xml:id attribute is "<sch:value-of select="."/>" 
                              but it should be "<sch:value-of select="concat($parentDivID, '.1')"/>".
                           </sch:assert>
                        </sch:rule>
                        
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="n" usage="req" mode="change">
                        <datatype>
                           <dataRef key="teidata.text"/>
                        </datatype>
                     </attDef>
                     <attDef ident="xml:id" usage="req" mode="change">
                        <datatype>
                           <dataRef key="ID"/>
                        </datatype>
                     </attDef>
                  </attList>
                  <!--
                     @xml:id required, value = "[roman #].\d+". Roman # might need to accommodate multiple layers of section numbers.
                     @n required, value = [# equaling roman num on id].\d+ = id substring-after .]
                     
                  -->
               </elementSpec>
               
               
               <elementSpec ident="body" module="textstructure" mode="change">
                  <content>
                     <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
                        <elementRef key="div" minOccurs="1" maxOccurs="3"/>
                        <elementRef key="noteGrp" minOccurs="1" maxOccurs="1"/>
                     </sequence>
                  </content>
               </elementSpec>
               
               
               <elementSpec ident="div" module="textstructure" mode="change">
                  <content>
                     <sequence preserveOrder="false">
                        <elementRef key="head" minOccurs="0" maxOccurs="2"/>
                        <alternate>
                           <elementRef key="ab" maxOccurs="unbounded"/>
                           <elementRef key="div" maxOccurs="unbounded"/>
                           <elementRef key="lg" maxOccurs="unbounded"/>
                        </alternate>
                        <elementRef key="trailer" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="pb" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
                  <constraintSpec ident="divAtts" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:body//tei:div[@type = 'conclusion']">
                           <sch:report test="@n">
                              An @n attribute not allowed here. If a portion of text should appear 
                              in a &lt;div&gt; that needs an @n attribute, put that section of text 
                              into a &lt;div&gt; with a @type attribute having the value "section".
                           </sch:report>
                           <sch:assert test="@xml:id='conclusion'">
                              This &lt;div&gt; element must have an @xml:id attribute with the value "work".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:body//tei:div[@type = 'introduction']">
                           <sch:report test="@n">
                              An @n attribute not allowed here. If a portion of text should appear 
                              in a &lt;div&gt; that needs an @n attribute, put that section of text 
                              into a &lt;div&gt; with a @type attribute having the value "section".
                           </sch:report>
                           <sch:assert test="@xml:id='intro'">
                              This &lt;div&gt; element must have an @xml:id attribute with the value "intro".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:body//tei:div[@type = 'section']">
                           <!--<sch:assert test="@n">
                              A &lt;div&gt; with a @type attribute having the value "section" requires
                              an @n attribute.
                           </sch:assert>-->
                           <sch:assert test="starts-with(@xml:id, 'section')">
                              This &lt;div&gt; element must have an @xml:id attribute that starts with "section".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:body//tei:div[@type = 'trailer']">
                           <sch:report test="@n">
                              An @n attribute not allowed here. If a portion of text should appear 
                              in a &lt;div&gt; that needs an @n attribute, put that section of text 
                              into a &lt;div&gt; with a @type attribute having the value "section".
                           </sch:report>
                           <sch:assert test="@xml:id='trailer'">
                              This &lt;div&gt; element must have an @xml:id attribute with the value "trailer".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:body//tei:div[@type = 'work']">
                           <sch:report test="@n">
                              A &lt;div&gt; with a @type attribute having the value "work" cannot have an 
                              @n attribute.
                           </sch:report>
                           <sch:assert test="@xml:id='work'">
                              This &lt;div&gt; element must have an @xml:id attribute with the value "work".
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="xmlID-on-div" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:body/tei:div/child::tei:div[@n]/@xml:id">
                           <sch:assert test="substring-after(., 'section-') eq parent::tei:div/@n">
                              The @xml:id is "<sch:value-of select="."/>" but it should be 
                              "<sch:value-of select="concat('section-', parent::tei:div/@n)"/>".
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <constraintSpec ident="n-on-div" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:body//tei:div[@type = 'section'][not(sibling::tei:div[@type = 'section'])][not(child::tei:div[@type = 'section'])]">
                           <sch:assert test="@n">
                              This &lt;div&gt; requires an @n attribute.
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:body/tei:div/tei:div[@n]/descendant::tei:div[@n][1]">
                           <sch:let name="parentDivN" value="number(parent::tei:div/@n)"/>
                           <sch:assert test="@n = $parentDivN + .1">
                              The element &lt;div&gt; is out of sequence. The @n attribute is "<sch:value-of select="@n"/>" 
                              but it should be "<sch:value-of select="$parentDivN + .1"/>".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:body/tei:div/tei:div[@n]/child::tei:div[@n][preceding-sibling::tei:div]">
                           <sch:let name="parentDivN" value="parent::tei:div/@n"/>
                           <sch:let name="previousNAtt" value="preceding-sibling::tei:div[1]/@n"/>
                           <sch:let name="previousSequence" value="number(tokenize($previousNAtt, '\.')[last()])"/>
                           <sch:let name="expectedSequence" value="$previousSequence + 1"/>
                           <sch:let name="expectedNAtt" value="concat($parentDivN, '.', $expectedSequence)"/>
                           <sch:assert test="@n = $expectedNAtt">
                              The element &lt;div&gt; is out of sequence. The @n attribute is "<sch:value-of select="@n"/>" 
                              but it should be "<sch:value-of select="$expectedNAtt"/>".
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" usage="req" mode="change">
                        <valList type="closed">
                           <valItem ident="conclusion">
                              <desc>A conclusion that is the equivalent of a chapter but not
                              numbered among the chapters of the work.</desc>
                           </valItem>
                           <valItem ident="introduction">
                              <desc>An introduction that is the equivalent of a chapter but not
                                 numbered among the chapters of the work.</desc>
                           </valItem><valItem ident="preface">
                              <desc>A short introduction to a collection of works not a part of a single
                              work but not substantial enough to be marked up as a work in 
                              it's own right. It cannot be a numbered section of the text.</desc>
                           </valItem>
                           <valItem ident="section">
                              <desc>A section of text; either an unnumbered text with only one section or a 
                              numbered section of a text.</desc>
                           </valItem>
                           <valItem ident="trailer">
                              <desc>A short conclusion to a collection of works not a part of a single
                              work but not substantial enough to be marked up as a work in
                              it's own right. It cannot be a numbered section of the text.</desc>
                           </valItem>
                           <valItem ident="work">
                              <desc>A work or as much of the work as it being encoded</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="xml:id" usage="req" mode="change"/>
                  </attList>
                  
                  <!--
                     @subtype = introduction, conclusion
                     @xml:id required, value = "[roman #].\d+ | .concl | .intro". Roman # might need to accommodate multiple layers of section numbers.
                     @n required unless there is a @subtype, value = [# equaling roman num on id].\d+ = id substring-after .]
                     
                  -->
               </elementSpec>
               
               
               <elementSpec ident="foreign" module="core" mode="change">
                  <constraintSpec ident="foreign-atts" scheme="schematron">
                     <constraint>
                        <sch:rule context="//tei:foreign">
                           <sch:assert test="@rend | @xml:lang">
                              A &lt;foreign&gt; element must have either an @xml:lang attribute
                              or a @rend attribute with the value "italics". The latter is used in
                              cases where the foreign word is transliterated from another script
                              in Latin letters.
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="//tei:foreign[@type]">
                           <sch:assert test="@rend">
                              A &lt;foreign&gt; element containing a transliteration must have a 
                              @rend attribute with the value "italics". 
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="//tei:foreign[@xml:lang/contains(., 'syr')]">
                           <sch:assert test="@dir" role="error">
                              Must contain a @dir attribute.
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="//tei:foreign[@xml:lang/not(contains(., 'syr'))]">
                           <sch:report test="@dir" role="error">
                              Cannot contain a @dir attribute.
                           </sch:report>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="dir" mode="add">
                        <valList type="closed">
                           <valItem ident="rtl">
                              <desc>Indicates to Oxygen XML Editor that text is to be rendered right-to-left.</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="rend" mode="change">
                        <valList type="closed">
                           <valItem ident="italics">
                              <desc>Indicates that a foreign word transliterated into English should be italicized</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="xml:lang" mode="change" usage="rec">
                        <valList type="closed">
                           <valItem ident="syr">
                              <desc>Syriac of any variety or period</desc>
                           </valItem>
                           <valItem ident="ar">
                              <desc>Arabic of any variety or period</desc>
                           </valItem>
                           <valItem ident="cop">
                              <desc>Coptic of any variety or period</desc>
                           </valItem>
                           <valItem ident="fr">
                              <desc>French of any variety or period</desc>
                           </valItem>
                           <valItem ident="de">
                              <desc>German of any variety or period</desc>
                           </valItem>
                           <valItem ident="grc">
                              <desc>Ancient Greek to A.D. 1453</desc>
                           </valItem>
                           <valItem ident="la">
                              <desc>Latin of any variety or period</desc>
                           </valItem>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>
               
               
               <elementSpec ident="head" module="core" mode="change">
                  <attList>
                     <attDef ident="type" usage="req" mode="change">
                        <valList type="closed">
                           <valItem ident="main"/>
                           <valItem ident="section"/>
                           <valItem ident="sub"/>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>
               
               
               <elementSpec ident="hi" module="core" mode="change">
                  <attList>
                     <attDef ident="rend" usage="req" mode="change">
                        <valList type="closed">
                           <valItem ident="bold"/>
                           <valItem ident="doubleQuotes"/>
                           <valItem ident="italics"/>
                           <valItem ident="singleQuotes"/>
                           <valItem ident="underline"/>
                        </valList>
                     </attDef>
                  </attList>
               </elementSpec>
               
               
               <elementSpec ident="l" module="core" mode="change">
                  <content>
                     <sequence preserveOrder="false">
                        <textNode/>
                        <elementRef key="choice" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="foreign" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="hi" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="pb" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="persName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="ptr" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="quote" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="title" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
                  <!--
                     @xml:id required, value = "[roman #].\d+". Roman # might need to accommodate multiple layers of section numbers.
                     @n required, value = [# equaling roman num on id].\d+ = id substring-after .]
                     
                  -->
               </elementSpec>
               
               
               <elementSpec ident="lg" module="core" mode="change">
                  <content>
                     <alternate minOccurs="1" maxOccurs="unbounded">
                        <elementRef key="l" maxOccurs="unbounded"/>
                        <elementRef key="lg" maxOccurs="unbounded"/>
                        <elementRef key="pb" minOccurs="0" maxOccurs="unbounded"/>
                     </alternate>
                  </content>
                  <!--
                     @xml:id required, value = "[roman #].\d+". Roman # might need to accommodate multiple layers of section numbers.
                     @n required, value = [# equaling roman num on id].\d+ = id substring-after .]
                     
                  -->
               </elementSpec>
               
               
               <elementSpec ident="note" module="core" mode="change">
                  <content>
                     <sequence preserveOrder="false">
                        <textNode/>
                        <elementRef key="ab" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="choice" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="foreign" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="hi" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="pb" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="persName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="ptr" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="quote" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="title" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
                  
                  <constraintSpec ident="note-attrs" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:note">
                           <sch:assert test="substring-after(@xml:id, 'n') eq @n">
                              The portion of the @xml:id attribute after "n" must match the @n attribute: 
                              "<sch:value-of select="@n"/>".
                           </sch:assert>
                           <sch:assert test="substring-after(@target, '#a') eq @n">
                              The portion of the @target attribute after "#a" must match the @n attribute: 
                              "<sch:value-of select="@n"/>".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:note/@xml:id">
                           <sch:assert test="starts-with(., 'n')">
                              The @xml:id must begin with "n".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:note/@target">
                           <sch:let name="anchors" value="//tei:body//tei:ptr[@type='noteAnchor']/@xml:id"/>
                           <sch:let name="anchorValues" value="for $i in $anchors return $i"/>
                           <sch:assert test="
                              every $i in substring-after(., '#')
                              satisfies $i = $anchorValues">
                              This @target attribute, <sch:value-of select="."/>, does not point to an existing @xml:id on 
                              a &lt;ptr&gt; element of @type "noteAnchor".
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  
                  <attList>
                     <!-- Is there an attribute that can point back to the anchor? -->
                     <!-- Is there an attribute that can apply an alt numbering system? -->
                     <attDef ident="xml:id" usage="req" mode="change"/>
                     <attDef ident="n" usage="req" mode="change"></attDef>
                  </attList>
               </elementSpec>
               
               
               <elementSpec ident="noteGrp" module="core" mode="change">
                  <content>
                     <sequence minOccurs="1" maxOccurs="1" preserveOrder="true">
                        <elementRef key="desc" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="note" minOccurs="1" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
               </elementSpec>
               
               
               <elementSpec ident="persName" module="namesdates" mode="change">
                  <content>
                     <sequence>
                        <textNode/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="pb" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
                  <attList>
                     <attDef ident="ref" usage="rec" mode="change">
                        <datatype minOccurs="1" maxOccurs="1">
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                        <constraintSpec ident="ref-on-persName" scheme="schematron">
                           <constraint>
                              <sch:rule context="//tei:text//tei:persName/@ref">
                                 <sch:let name="personIndex" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/persons.xml')"></sch:let>
                                 <sch:let name="personURIs" value="$personIndex//tei:person/@ref"/>
                                 <sch:let name="error" value="."/>
                                 <sch:report test="contains(., ' ')" role="error">This @ref may contain only one URI.</sch:report>
                                 <sch:assert test="matches(., concat('http://syriaca.org/person/', '\d+'))" role="error">
                                    The @ref attribute must take a Syriaca.org person URI which reqires 
                                    the form 'http://syriaca.org/person/{\d+}' (where {\d+} is a number).
                                 </sch:assert>
                                 <sch:assert test="
                                    every $i in .
                                    satisfies $i = $personURIs" role="warning">
                                    <sch:value-of select="$error"/> is not currently in use. 
                                    Note that all person URIs take the form 'http://syriaca.org/person/{\d+}' 
                                    (where {\d+} is a number). If a URI is not current available, replace the number portion of the URI with 
                                    "#" followed without a space by a number that you use consistently when encoding information 
                                    about that person. 
                                 </sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                     </attDef>
                  </attList>
               </elementSpec>
               
               
               <elementSpec ident="placeName" module="namesdates" mode="change">
                  <content>
                     <sequence>
                        <textNode/>
                        <elementRef key="persName" minOccurs="0" maxOccurs="1"/>
                        <elementRef key="pb" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
                  <attList>
                     <attDef ident="ref" usage="rec" mode="change">
                        <datatype minOccurs="1" maxOccurs="1">
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                        <constraintSpec ident="ref-on-placeName" scheme="schematron">
                           <constraint>
                              <sch:rule context="//tei:text//tei:placeName/@ref">
                                 <sch:let name="placeIndex" value="doc('https://raw.githubusercontent.com/srophe/syriaca/master/documentation/indexes/places.xml')"/>
                                 <sch:let name="placeURIs" value="$placeIndex//tei:place/@ref"/>
                                 <sch:let name="error" value="."/>
                                 <sch:report test="contains(., ' ')" role="error">This @ref may contain only one URI.</sch:report>
                                 <sch:assert test="matches(., concat('http://syriaca.org/place/', '\d+'))" role="error">
                                    The @ref attribute must take a Syriaca.org place URI which reqires 
                                    the form 'http://syriaca.org/place/{\d+}' (where {\d+} is a number).
                                 </sch:assert>
                                 <sch:assert test="
                                    every $i in .
                                    satisfies $i = $placeURIs" role="warning">
                                    <sch:value-of select="$error"/> is not currently in use. 
                                    Note that all properly formatted place URIs take the form 'http://syriaca.org/place/{\d+}' 
                                    (where {\d+} is a number). If a URI is not current available, replace the number portion of the URI with 
                                    "#" followed without a space by a number that you use consistently when encoding information 
                                    referring to that place. 
                                 </sch:assert>
                              </sch:rule>
                           </constraint>
                        </constraintSpec>
                     </attDef>
                  </attList>
               </elementSpec>
               
               
               <elementSpec ident="ptr" module="core" mode="change">
                  <constraintSpec ident="ptr-atts" scheme="schematron">
                     <constraint>
                        <sch:rule context="tei:ptr[@type='noteAnchor']">
                           <sch:assert test="substring-after(@xml:id, 'a') eq @n">
                              The portion of the @xml:id attribute after "a" must match the @n attribute: 
                              "<sch:value-of select="@n"/>".
                           </sch:assert>
                           <sch:assert test="substring-after(@target, '#n') eq @n">
                              The portion of the @target attribute after "#n" must match the @n attribute: 
                              "<sch:value-of select="@n"/>".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:ptr/@xml:id">
                           <sch:assert test="starts-with(., 'a')">
                              The @xml:id must begin with "a".
                           </sch:assert>
                        </sch:rule>
                        <sch:rule context="tei:ptr/@target">
                           <sch:let name="notes" value="//tei:noteGrp//tei:note/@xml:id"/>
                           <sch:let name="noteValues" value="for $i in $notes return $i"/>
                           <sch:assert test="
                              every $i in substring-after(., '#')
                              satisfies $i = $noteValues">
                              This @target attribute, <sch:value-of select="."/>, does not point to an existing @xml:id on 
                              a &lt;note&gt; element.
                           </sch:assert>
                        </sch:rule>
                     </constraint>
                  </constraintSpec>
                  <attList>
                     <attDef ident="type" usage="req" mode="change">
                        <valList type="closed">
                           <valItem ident="noteAnchor">
                              <desc>Anchor in the text used to point to a note</desc>
                           </valItem>
                        </valList>
                     </attDef>
                     <attDef ident="xml:id" usage="req" mode="change"/>
                     <attDef ident="target" usage="req" mode="change">
                        <datatype minOccurs="1" maxOccurs="unbounded">
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </elementSpec>
               
               
               <elementSpec ident="quote" module="linking" mode="change">
                  <content>
                     <sequence preserveOrder="false">
                        <textNode/>
                        <elementRef key="choice" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="foreign" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="hi" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="pb" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="persName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="placeName" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="ptr" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="quote" minOccurs="0" maxOccurs="unbounded"/>
                        <elementRef key="title" minOccurs="0" maxOccurs="unbounded"/>
                     </sequence>
                  </content>
                  <attList>
                     <attDef ident="source" usage="opt" mode="change">
                        <datatype minOccurs="1" maxOccurs="unbounded">
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </elementSpec>
               
               
               <elementSpec ident="text" module="textstructure" mode="change">
                  <content>
                     <elementRef key="body" maxOccurs="1" minOccurs="1"/>
                  </content>
               </elementSpec>
               
               
               <elementSpec ident="title" module="core" mode="change">
                  <attList>
                     <attDef ident="ref" usage="rec" mode="change">
                        <datatype minOccurs="1" maxOccurs="unbounded">
                           <dataRef key="teidata.pointer"/>
                        </datatype>
                     </attDef>
                  </attList>
               </elementSpec>
               
               
                             
               
               
            </schemaSpec>
         </div>
      </body>
   </text>
</TEI>
